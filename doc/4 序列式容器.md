
&emsp;&emsp;容器是指实例为其他类的对象的集合的类、数据结构或者抽象数据类型。换言之，它们以一种遵循特定访问规则的系统的方法来存储对象。容器的大小取决于其包含的对象（或元素）的数目。潜在的不同容器类型的实现可能在空间和时间复杂度上有所差别，这使得在给定应用场景中选择合适的某种实现具有灵活性。
&emsp;&emsp;序列式容器即容器可以有序，但是不一定有序。C++语言本身提供了一个静态数组容器```array```，STL提供了```vector,list,deque,heap,priority_queue,list,slist```几种容器，另外的```stack,queue```是基于```deque```的封装，更像一种配接器。
# 1 vector
&emsp;&emsp;```vector```是一种动态数组，其中的内存空间根据用户需要的空间大小自动分配。
## 1.1 vector基本数据结构
```cpp
template <class T, class Alloc = alloc>
class vector {
public:
  typedef T value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

protected:
  typedef simple_alloc<value_type, Alloc> data_allocator;
  iterator start;
  iterator finish;
  iterator end_of_storage;
}
```

&emsp;&emsp;```vector```的基本数据累心如上面所述，```public```部分为基本的容器类型相关内容，另外能够看到的是```vecotor```使用的分配器是之前提到的```simple_alloc```。
&emsp;&emsp;```vector```的迭代器就是类型的普通指针，而其数据域是通过```start,finish, end_of_storage```来指示元素。其中```[start, end)```为用户实际上操作数据使用的空间，而```[start, end_of_storage)```是内部维护的实际空间大小，也就是说当用户申请一定大小的空间时，```vector```并不会完全按照用户的要求分配固定大小的空间而是将该大小向上对齐，额外分配空间保证尽可能的减少对内存分配函数的调用。
![](img/vector_mem.drawio.svg)


## 1.2 vector
## 1.3 
# 2 list
&emsp;&emsp;
# 3 deque
&emsp;&emsp;